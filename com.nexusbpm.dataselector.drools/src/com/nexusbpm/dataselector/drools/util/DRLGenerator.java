package com.nexusbpm.dataselector.drools.util;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import com.nexusbpm.dataselector.conditions.DataConditionGenerator;
import com.nexusbpm.dataselector.drools.model.PropertyList;
import com.nexusbpm.dataselector.drools.model.PropertyMap;
import com.nexusbpm.dataselector.model.LSNode;
import com.nexusbpm.dataselector.model.LSTree;

public class DRLGenerator {
    public DRLGenerator() {
    }
    
    public String generateDRL(LSTree tree) {
        String newline = System.getProperty("line.separator");
        DataConditionGenerator gen = new DroolsConditionGenerator();
        PropertyList list = PropertyList.get(tree, false);
        
        Set<String> inputColumns = new TreeSet<String>();
        
        List<LSNode> queue = new LinkedList<LSNode>();
        queue.add(tree.getRoot());
        
        StringBuilder b = new StringBuilder();
        
        b.append("package com.nexusbpm.drools").append(newline);
        b.append("import com.nexusbpm.drools.ComparisonUtil;").append(newline);
        b.append("import java.util.HashMap;").append(newline);
        b.append("global java.util.HashMap output;").append(newline).append(newline);
        
        while(queue.size() > 0) {
            LSNode node = queue.remove(0);
            queue.addAll(node.getSubNodes());
            
            PropertyMap map = PropertyMap.get(node, false);
            
            if(map != null) {
                LSNode n = node;
                while(n.getConnector() != null) {
                    n = n.getConnector().getSource();
                    inputColumns.add(n.getSplit().getColumn());
                }
                int index = tree.getNodeIndex(node);
                b.append("rule \"node").append(index).append("\"").append(newline);
                
                // give each rule the same group and a different salience so that only
                // the rule for the most specific segment will fire
                b.append("\tactivation-group \"data-selector-group\"").append(newline);
                b.append("\tsalience ").append(index).append(newline);
                
                // condition (LHS)
                b.append("\twhen").append(newline);
                String condition = gen.getFullConditionString(node, null);
                if(condition.length() == 0) {
                    b.append("\t\tinput : HashMap()").append(newline);
                } else {
                    b.append("\t\tinput : HashMap(eval(").append(newline);
                    b.append("\t\t\t").append(gen.getFullConditionString(node, null)).append(newline);
                    b.append("\t\t\t))").append(newline);
                }
                
                // consequence (RHS)
                b.append("\tthen").append(newline);
                for(String name : list.getValues()) {
                    b.append("\t\toutput.put(\"").append(name).append("\", ");
                    String value = map.getValues().get(name);
                    if(value == null) {
                        b.append("null");
                    } else {
                        b.append(getValueString(value, inputColumns));
                    }
                    b.append(");").append(newline);
                }
                
                b.append("end").append(newline).append(newline);
            }
        }
        
        // header
        StringBuilder header = new StringBuilder();
        header.append("# This rules file was generated by DataSelector").append(newline);
        header.append("# Warning: Do not hand modify this file").append(newline);
        header.append("# ").append(newline);
        
        // input columns
        header.append("# input columns: ");
        append(header, inputColumns);
        header.append(newline);
        
        // output columns
        header.append("# output columns: ");
        append(header, list.getValues());
        header.append(newline).append(newline);
        
        
        b.insert(0, header.toString());
        
        return b.toString();
    }
    
    protected void append(StringBuilder builder, Collection<String> names) {
        if(names.size() > 0) {
            boolean first = true;
            for(String name : names) {
                if(first) {
                    first = false;
                } else {
                    builder.append(", ");
                }
                builder.append(name);
            }
        }
    }
    
    protected String getValueString(String value, Set<String> inputColumns) {
        StringBuilder b = new StringBuilder();
        b.append('"');
        for(int index = 0; index < value.length(); ) {
            boolean added = false;
            if(index + 1 < value.length() &&
                    value.charAt(index) == '$' && value.charAt(index + 1) == '{') {
                if(index == 0 || (index > 0 && value.charAt(index - 1) != '$')) {
                    int index2 = value.indexOf('}', index);
                    if(index2 > index + 2) {
                        b.append("\" + input.get(\"");
                        String name = value.substring(index + 2, index2);
                        b.append(name);
                        inputColumns.add(name);
                        b.append("\") + \"");
                        index = index2 + 1;
                        added = true;
                    }
                }
            }
            if(!added) {
                if(value.charAt(index) == '"') {
                    b.append('\\');
                }
                b.append(value.charAt(index));
                index += 1;
            }
        }
        b.append('"');
        
        // we can't delete an empty starting string because the java code we're generating
        // needs to indicate to java that the + is string concatenation (java doesn't know
        // what the + operator means for Objects in general)
//        if(b.substring(0, 5).equals("\"\" + ")) {
//            b.delete(0, 5);
//        }
        if(b.length() > 5 && b.substring(b.length() - 5, b.length()).equals(" + \"\"")) {
            b.delete(b.length() - 5, b.length());
        }
        while(b.indexOf("+ \"\" +") != -1) {
            int index = b.indexOf("+ \"\" +");
            b.delete(index, index + 5);
        }
        return b.toString();
    }
}
